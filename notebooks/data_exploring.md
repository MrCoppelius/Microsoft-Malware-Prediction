```python
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pickle
from dask_ml import preprocessing
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import OrdinalEncoder
from malware_ml import transformators
from malware_ml.visualization import draw_histograms_by_target, draw_corr_matrix
from malware_ml.data_exploring import make_df_by_data_info, count_data_info
%matplotlib inline
```

**Типы данных для считывания. Взяты  из ноутбука на сайте конкурса, позволяют немного уменьшить размер представления датасета в pandas.**


```python
dtypes = {
        'MachineIdentifier':                                    'category',
        'ProductName':                                          'category',
        'EngineVersion':                                        'category',
        'AppVersion':                                           'category',
        'AvSigVersion':                                         'category',
        'IsBeta':                                               'int8',
        'RtpStateBitfield':                                     'float16',
        'IsSxsPassiveMode':                                     'int8',
        'DefaultBrowsersIdentifier':                            'float32',
        'AVProductStatesIdentifier':                            'float32',
        'AVProductsInstalled':                                  'float16',
        'AVProductsEnabled':                                    'float16',
        'HasTpm':                                               'int8',
        'CountryIdentifier':                                    'int16',
        'CityIdentifier':                                       'float32',
        'OrganizationIdentifier':                               'float16',
        'GeoNameIdentifier':                                    'float16',
        'LocaleEnglishNameIdentifier':                          'int16',
        'Platform':                                             'category',
        'Processor':                                            'category',
        'OsVer':                                                'category',
        'OsBuild':                                              'int16',
        'OsSuite':                                              'int16',
        'OsPlatformSubRelease':                                 'category',
        'OsBuildLab':                                           'category',
        'SkuEdition':                                           'category',
        'IsProtected':                                          'float16',
        'AutoSampleOptIn':                                      'int8',
        'PuaMode':                                              'category',
        'SMode':                                                'float16',
        'IeVerIdentifier':                                      'float16',
        'SmartScreen':                                          'category',
        'Firewall':                                             'float16',
        'UacLuaenable':                                         'float64', 
        'Census_MDC2FormFactor':                                'category',
        'Census_DeviceFamily':                                  'category',
        'Census_OEMNameIdentifier':                             'float32', 
        'Census_OEMModelIdentifier':                            'float32',
        'Census_ProcessorCoreCount':                            'float16',
        'Census_ProcessorManufacturerIdentifier':               'float16',
        'Census_ProcessorModelIdentifier':                      'float32', 
        'Census_ProcessorClass':                                'category',
        'Census_PrimaryDiskTotalCapacity':                      'float64', 
        'Census_PrimaryDiskTypeName':                           'category',
        'Census_SystemVolumeTotalCapacity':                     'float64', 
        'Census_HasOpticalDiskDrive':                           'int8',
        'Census_TotalPhysicalRAM':                              'float32',
        'Census_ChassisTypeName':                               'category',
        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float32', 
        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float32',
        'Census_InternalPrimaryDisplayResolutionVertical':      'float32', 
        'Census_PowerPlatformRoleName':                         'category',
        'Census_InternalBatteryType':                           'category',
        'Census_InternalBatteryNumberOfCharges':                'float64', 
        'Census_OSVersion':                                     'category',
        'Census_OSArchitecture':                                'category',
        'Census_OSBranch':                                      'category',
        'Census_OSBuildNumber':                                 'int16',
        'Census_OSBuildRevision':                               'int32',
        'Census_OSEdition':                                     'category',
        'Census_OSSkuName':                                     'category',
        'Census_OSInstallTypeName':                             'category',
        'Census_OSInstallLanguageIdentifier':                   'float16',
        'Census_OSUILocaleIdentifier':                          'int16',
        'Census_OSWUAutoUpdateOptionsName':                     'category',
        'Census_IsPortableOperatingSystem':                     'int8',
        'Census_GenuineStateName':                              'category',
        'Census_ActivationChannel':                             'category',
        'Census_IsFlightingInternal':                           'float16',
        'Census_IsFlightsDisabled':                             'float16',
        'Census_FlightRing':                                    'category',
        'Census_ThresholdOptIn':                                'float16',
        'Census_FirmwareManufacturerIdentifier':                'float16',
        'Census_FirmwareVersionIdentifier':                     'float32',
        'Census_IsSecureBootEnabled':                           'int8',
        'Census_IsWIMBootEnabled':                              'float16',
        'Census_IsVirtualDevice':                               'float16',
        'Census_IsTouchEnabled':                                'int8',
        'Census_IsPenCapable':                                  'int8',
        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
        'Wdft_IsGamer':                                         'float16',
        'Wdft_RegionIdentifier':                                'float16',
        'HasDetections':                                        'int8'
        }
```


```python
df = pd.read_csv('../data/train.csv', dtype = dtypes, nrows = 1000000)
```


```python
df.head()

```

**Подсчитаем основную информацию о признаках.**


```python
data_info_df = count_data_info(df)
data_info_df.sort_values(by='percent of null values', ascending = False).head(20)
```


```python
data_info_df.sort_values(by='percent of most popular values', ascending = False).head(20)
```

**Найдем признаки у которых больше  99% значений  принадлежат к одной категории**


```python
test_df = make_df_by_data_info(df, data_info_df, 'percent of most popular values', 99)
```

**Построим гистограмы для данных признаков в зависимости от целевой переменной. Убедимся, что данные признаки примерно одинаково  распределены между классами целевой переменной и их можно удалить.**


```python
draw_histograms_by_target(test_df, 'HasDetections')
```


```python
columns_to_drop = set(test_df.columns)

```

**Проделаем ту же операцию с признаками у которых количество неопределенных значений больше 60%**


```python
test_df = make_df_by_data_info(df, data_info_df, 'percent of null values', 60)
```


```python
draw_histograms_by_target(test_df,'HasDetections')
```


```python
columns_to_drop.update(test_df.columns)
columns_to_drop.update(['MachineIdentifier'])
columns_to_drop.discard('HasDetections')
columns_to_drop
```


```python
all_columns = set(df.columns)
X = df.drop(all_columns & columns_to_drop, axis = 1)
```


```python
numeric_features = {'Census_SystemVolumeTotalCapacity', 
                    'Census_InternalBatteryNumberOfCharges', 
                    'Census_PrimaryDiskTotalCapacity', 
                    'Census_InternalPrimaryDiagonalDisplaySizeInInches',
                    'Census_TotalPhysicalRAM',
                    'Census_InternalPrimaryDisplayResolutionHorizontal',
                    'Census_InternalPrimaryDisplayResolutionVertical',
                    'Census_ProcessorCoreCount'}
```

**Преобразуем категориальные признаки к числовому представлению и посчитаем корреляционную матрицу.**


```python
si = transformators.ConstantImputer(-1)
X = si.fit_transform(X)
cat = transformators.CategoriсalFeaturesTransformer(numeric_features)
X = cat.fit_transform(X)
oe = preprocessing.OrdinalEncoder()
X = oe.fit_transform(X)
```


```python
draw_corr_matrix(X.corr())
```

**Найдем пары сильно коррелированных  признаков.**


```python
indices = np.where(X.corr().abs() > 0.98)
indices = [(X.columns[x], X.columns[y]) for x, y in zip(*indices)
                                        if x != y and x < y]
indices
```


```python
indices = np.append(np.array(indices).reshape(6),'HasDetections')
```

**Посмотрим на матрицу  корреляции для данных признаков и целевой переменной**


```python
draw_corr_matrix(X[indices].corr(), True)
```

**Сильно коррелированные признаки могут ухудшить качество обучения модели, поэтому выберем из каждой пары  сильно коррелированых признаков один и удалим его.**


```python
all_columns = set(df.columns)
high_corr_to_drop  = {'Processor','Census_OSSkuName', 'Census_OSInstallLanguageIdentifier' }
columns_to_drop.update(high_corr_to_drop)


```

**После того, как 'плохие' столбцы найдены, разобьем все признаки на группы: числовые, категориальные бинарные, категориальные для One Hot кодирования и категориальные для Ordinal  кодирования.**


```python
X = df.drop(columns_to_drop & all_columns, axis = 1)
data_info_df = count_data_info(X)
```


```python
pd.set_option('display.max_rows',data_info_df.shape[0])
data_info_df.sort_values(by='unique values', ascending = False).loc[:]
```


```python
test_df  = make_df_by_data_info(X, data_info_df, 'unique values', 2, False)
```


```python
categorical_features_binary  = set(test_df.columns)
categorical_features_binary.difference_update(numeric_features| set(['HasDetections']))
categorical_features_binary
```


```python
test_df  = make_df_by_data_info(X, data_info_df, 'unique values', 1000, False)
```


```python
categorical_features_OHE = set(test_df.columns)
categorical_features_OHE.difference_update( categorical_features_binary | numeric_features | set(['HasDetections']))
categorical_features_OHE_index = [df.columns.get_loc(c) for c in categorical_features_OHE if c in X]
categorical_features_OHE
```


```python
all_colmns = set(X.columns)
categorical_features_OE = all_colmns.difference(categorical_features_binary |
                                                categorical_features_OHE |
                                                numeric_features | 
                                                set(['HasDetections']))
categorical_features_OE
```

**&emsp;Опишем полную цепочку преобразования  данных и добавим  её в pipeline. Для этого реализуем несколько собственных трансформаторов. <br/> &emsp;Так как градиентный бустинг на основе решающих деревьев хорошо обрабатывает пропуски в данных самостоятельно, то  мы будем просто заполнять пропуски значением -1 (при обучении с помощью XGBClassifer можно указать какое значение считать за пропуск в данных). В признаках которые мы закодируем с помощью One Hot Encoder'a   появится дополнительный фиктивный столбец, что так же должно работать, если верить https://github.com/dmlc/xgboost/issues/3267**     


```python
ct = ColumnTransformer([("OrdinalEncoder",OrdinalEncoder(), list(categorical_features_OE)),
                        ("OneHotEncoder", OneHotEncoder(categories='auto', sparse = True ), list(categorical_features_OHE))],
                        remainder = 'passthrough', sparse_threshold=1)
pipl = Pipeline ( [ ('ColumnsDropper',transformators.ColumnsDropper(columns_to_drop | set(['HasDetections']))),
                    ('SimpleImputer',transformators.ConstantImputer(-1)),
                    ('ColumnsTransformer', ct)])
```


```python
X =  pipl.fit_transform(df)
```


```python
path = '../models/data_transformer_pipl.pkl'
pickle.dump(pipl, open(path,'wb'))
```


```python
df['HasDetections'].to_numpy()
```


```python
y = pipl.transform(df.iloc[:100, :])
```


```python
y
```


```python

```
